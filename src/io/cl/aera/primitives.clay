import aera.aera.*;
import aera.generated.*;
import strings.*;
import vectors.(Vector);

overload aeraGetType    (t:Int) = aera_int_t;
overload aeraGetInt     (t:Int) = t;

overload aeraGetType    (t:String) = aera_string_t;
overload aeraGetString  (t:String) = cstring(t);


alias AeraSeqArray?(T) = CoordinateSequence?(T) and AeraType?(SequenceElementType(T));

[T when AeraSeqArray?(T)] overload AeraArray?(#T) = true;
[T when AeraSeqArray?(T)] record   AeraSeqArrayIterator[T]
(
    it:  SequenceCoordinateType(T),
    end: SequenceCoordinateType(T)
);
overload AeraArrayIterator?(AeraSeqArrayIterator) = true;

[T when AeraSeqArray?(T)] overload aeraArrayNext (i:AeraSeqArrayIterator[T]) : aera_item
{
    if (i.it >= i.end)
        // FIXME: an exception for EOF? seriously?
        throw Exception();

    var r = liftAeraItem(@dereference(i.it), #false);
    inc(i.it);
    return r;
}

[T when AeraSeqArray?(T)] overload aeraGetArray(t:T) : aera_array
{
    var it = allocateObject(AeraSeqArrayIterator[T](begin(t), end(t)));
    return liftAeraArray(it, #true);
}



